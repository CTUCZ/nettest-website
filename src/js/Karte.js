/**
 * This script loads the data from the map server and displays it to the user
 * => All images and overlays are generated by the map server (including
 *  heatmaps and circles)
 * For each click in the map, the map server is contacted with the coordinates of
 * the click and responds by providing a list of all measurements near the clicked
 * point
 */

var cloudmade = false;
var useGoogle = true;
var useBasemapAT = true;
var useBingMaps = false;
var useRTRTiles = true;

var URL_MAP_SERVER = 'https://c01.control.netztest.at/RMBTMapServer/tiles';
//var URL_MAP_SERVER = 'https://develop.netztest.at/' + mappath + '/tiles';

var heatmap, points, map, markers;

var lastfeature;
var selectStop;
var curMapOptionObj = {};
var curFilterObj = {};
var click;
var points_heatmap_switch_level = 12;

/*
 *
 * Click Handler for popup
 */
OpenLayers.Control.Click = OpenLayers.Class(OpenLayers.Control, {
        defaultHandlerOptions: {
                'single': true,
                'double': true,
                'pixelTolerance': 0,
                'stopSingle': false,
                'stopDouble': false
        },
        initialize: function(options) {
                this.handlerOptions = OpenLayers.Util.extend({}, this.defaultHandlerOptions);
                OpenLayers.Control.prototype.initialize.apply(this, arguments);
                this.handler = new OpenLayers.Handler.Click(this, {
                        'click': this.trigger
                }, this.handlerOptions);
        },
        trigger: function(e) {
                loadMarker(map.getLonLatFromPixel(e.xy));
        }
});

$(document).ready(function() {
        //requestBrowserData('RMBTsettings', 'viewmap');

        var caption_low, caption_high, caption_unit;
        legends = new Object();


        // pink tile avoidance
        OpenLayers.IMAGE_RELOAD_ATTEMPTS = 5;
        // make OL compute scale according to WMS spec
        OpenLayers.DOTS_PER_INCH = 25.4 / 0.28;

        // Values for colored scale
        var interval_values = "5,30,70";
        var interval_colors = "#00ff00,#ffff00,#ff0000";

        var bases = new Array();
        var base_google;
        var base_basemap;
        var base_bing;
        var base_rtr;
        if (cloudmade)
        {
                base = new OpenLayers.Layer.CloudMade("CloudMade", {
                        key: '7baca6b0602643118b11e425f8618552',
                        isBaseLayer: true,
                        styleId: 998, //alternative: 1
                        numZoomLevels: 18,
                        transitionEffect: "resize"
                });
        }
        

        if (useBingMaps) {
            
            base_bing = new OpenLayers.Layer.Bing({
                name: " Bing Maps",
                key: bing_api_key,
                type: "Road",
                protocol: "https:"
            });
            bases.push(base_bing);
        }

        if (useGoogle) {
                base_google = new OpenLayers.Layer.Google(
                        " Google Maps", // the default
                        {numZoomLevels: 18}
                );
                bases.push(base_google);
        }

        if (useBasemapAT) {
                var extent = new OpenLayers.Bounds(1030000, 5800000, 1930000, 6330000);
                base_basemap = new OpenLayers.Layer.WMTS(
                        {
                                //url templates only allowed with single urls according to documentation
                                url: "https://maps.wien.gv.at/basemap/geolandbasemap/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.png",
                                //"http://maps2.wien.gv.at/basemap/geolandbasemap/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.jpeg",
                                //"http://maps3.wien.gv.at/basemap/geolandbasemap/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.jpeg",
                                //"http://maps4.wien.gv.at/basemap/geolandbasemap/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.jpeg"
                                //,
                                name: " Basemap.at",
                                isBaseLayer: true,
                                layer: "geolandbasemap",
                                style: "normal",
                                buffer: 0,
                                transitionEffect: "resize",
                                requestEncoding: "REST",
                                matrixSet: "google3857",
                                tileFullExtent: extent,
                                numZoomLevels: 18,
                                attribution: "<a href='http://www.basemap.at' target='_new'>Basemap.at</a>"
                        });
                base_basemap.metadata = {
                        link: "http://www.basemap.at/"
                };
                bases.push(base_basemap);
        }

        

        if (useRTRTiles)
        {
                base_rtr = new OpenLayers.Layer.OSM(" OpenStreetMap",
                        //"http://a.tile.openstreetmap.de/tiles/osmde/${z}/${x}/${y}.png",
                        "https://tile.rtr.at/osmde/${z}/${x}/${y}.png", {
                                isBaseLayer: true,
                                tileOptions: {
                                        crossOriginKeyword: null
                                },
                                transitionEffect: "resize",
                                numZoomLevels: 17,
                        });
                bases.push(base_rtr);
        }

        markers = new OpenLayers.Layer.Vector("Markers", {
            displayInLayerSwitcher: false
        });

        selectStop = new OpenLayers.Control.SelectFeature(markers, {
                onSelect: onFeatureSelect,
                onUnselect: onFeatureUnselect
        });

        markers.events.on({
                "featureselected": onFeatureSelect,
                "featureunselected": onFeatureUnselect
        });

        //var bounds = new OpenLayers.Bounds(1805891.0815372001, 6126605.126178115, 1843404.7925869129, 6158586.596166264);
        var bounds = new OpenLayers.Bounds();
        //bounds.extend(new OpenLayers.LonLat(1805891.0815372001, 6126605.126178115));
        //bounds.extend(new OpenLayers.LonLat(1843404.7925869129, 6158586.596166264));
        //bounds.extend(new OpenLayers.LonLat(1805891.0815372001, 6126605.126178115)); //Google-Koordinaten meiner letzten Messung.

        bounds.extend(new OpenLayers.LonLat(1252344.27125, 5846515.498922221)); //South West
        bounds.extend(new OpenLayers.LonLat(1907596.397450879, 6284446.2299491335)); //Nord East

        map = new OpenLayers.Map({
                div: "speedtestmap",
                controls: [
                        new OpenLayers.Control.Attribution(),
                        new OpenLayers.Control.Navigation({dragPanOptions: {enableKinetic: true}})
        ],
                //maxExtent : bounds,
                projection: (useBasemapAT || useGoogle || useBingMaps) ? "EPSG:4326" : "EPSG:900913",
                maxResolution: (useBasemapAT ||useGoogle || useBingMaps) ? 156543 : 146.53793378794035, //,
                units: "m"
    });

        var customToolBar = new OpenLayers.Control.Panel({});
        customToolBar.addControls([new OpenLayers.Control.Pan("North", {
                        title: "North",
                        displayClass: "panNorth"
                }), new OpenLayers.Control.Pan("East", {
                        title: "East",
                        displayClass: "panEast"
                }), new OpenLayers.Control.Pan("West", {
                        title: "West",
                        displayClass: "panWest"
                }), new OpenLayers.Control.Pan("South", {
                        title: "South",
                        displayClass: "panSouth"
                }), new OpenLayers.Control.ZoomIn({
                        title: "Zoom In",
                        displayClass: "zoomIn"
                }), new OpenLayers.Control.ZoomOut({
                        title: "Zoom Out",
                        displayClass: "zoomOut"
                }), new OpenLayers.Control.ScaleLine()]);
        map.addControl(customToolBar);

        //map.addLayers([base, heatmap, points, markers, shapes]);
        map.addLayers(bases);
        
        var layerSwitcher = new OpenLayers.Control.LayerSwitcher({
            ascending: true
        });
        //layerSwitcher.baseLbl.innerText;
        //layerSwitcher.baseLayers = [base_google, base_basemap, base_bing];
        map.addControl(layerSwitcher);
        $("#speedtestmap .baseLbl").html(Lang.getString('baseLayer'));

        requestBrowserData('RMBTmapfilter');



        //map.addControl(new OpenLayers.Control.LayerSwitcher());
        map.zoomToExtent(bounds);
        //map.zoomToMaxExtent();

        // Stop zoom at certain levels
        /*
         map.newMoveTo = map.moveTo;
         map.moveTo = function(lonlat, zoom, options) {
         return (zoom >= 1 && zoom <= 18) ? map.newMoveTo(lonlat, zoom, options) : false;
         };
         */

        map.addControl(selectStop);
        map.events.register('zoomend', null, displayZoom);
        selectStop.activate();

        //activate click handler for popups
        click = new OpenLayers.Control.Click();
        map.addControl(click);
        click.activate();

        $(this).find("input:radio[name='check_layer']").click(function() {
                setLayers();
        });
        
        geocoder_google = new google.maps.Geocoder();
        $("#address_search").submit(function() {
                searchAndPositionOnAddress();
                return false;
        })

        panToLastUserTest();
        panToUserPosition();
});

function convertLongLatToOpenLayersPoint(long,lat) {
    var pt = new OpenLayers.LonLat(long, lat);
    pt.transform(
            // degrees are degrees
            new OpenLayers.Projection('EPSG:4326'),
            // but your map is in meters (probably)
            new OpenLayers.Projection('EPSG:900913'));
    return pt;
}

var geocoder_google;
function searchAndPositionOnAddress() {
        var address = $("#address_search #address_search_input").val();
        
        //add "Austria" for ZIP Codes
        if (parseInt(address) !== NaN && parseInt(address) > 0) {
            address += ", Austria";
        }
        
        
        $('#spinner').spin('modal');
        
        geocoder_google.geocode( { 'address': address}, function(results, status) {
                $('#spinner').spin('modal');
                if (status === google.maps.GeocoderStatus.OK) {
                        var pan = function(i) {
                            $("#address_search .address_input").show();
                            $("#address_search .selection").hide();

                            $("#address_search #address_search_input").val(results[i].formatted_address);

                            var bounds = new OpenLayers.Bounds();
                            bounds.extend(convertLongLatToOpenLayersPoint(results[i].geometry.viewport.getNorthEast().lng(), results[i].geometry.viewport.getNorthEast().lat())); //North East
                            bounds.extend(convertLongLatToOpenLayersPoint(results[i].geometry.viewport.getSouthWest().lng(), results[i].geometry.viewport.getSouthWest().lat())); //South West
                            map.zoomToExtent(bounds);
                        };
                
                        if (results.length > 1) {
                            $("#address_search .address_input").hide();
                            $("#address_search .selection").show();
                            $("#address_selection").empty();
                            $("#address_selection").unbind("change");
                            $("#address_selection").append("<option value='-1'>" + Lang.getString("pleaseSelect") + "</option>");
                            
                            
                            //address not unique
                            for(var i=0;i<results.length;i++) {
                                $("#address_selection").append("<option value='" + i +  "'>" + results[i].formatted_address + "</option>");
                            }
                            
                            $("#address_selection").bind("change", function() {
                                var id = $("#address_selection").val();
                                if (id >= 0) {
                                    pan(id);
                                }
                            });
                        }
                        else {
                            pan(0);
                        }                       
                        
                } else {
                        alert(Lang.getString('addressNotFound'));
                }
        });
        
}

function panToLastUserTest() {
    //copied from geolocation, cannot directly use due to side effects
        var coords = getCookie('coords');
        //console.log(coords);
        if (coords) {
                coords = JSON.parse(coords);
                //console.log(tmpcoords);
        }
        if (coords && coords['lat'] > 0 && coords['long'] > 0) {
                var lat = coords['lat'];
                var long = coords['long'];
                //alert(lat + ", " + long);

                var pt = new OpenLayers.LonLat(long, lat);
                pt.transform(
                        // degrees are degrees
                        new OpenLayers.Projection('EPSG:4326'),
                        // but your map is in meters (probably)
                        new OpenLayers.Projection('EPSG:900913'));
                var zoomLevel = 11;
                if (coords['accuracy'] !== null) {
                        if (coords['accuracy'] < 100) {
                                zoomLevel = 17;
                        }
                        else if (coords['accuracy'] < 1000) {
                                zoomLevel = 13;
                        }
                }
                map.setCenter(pt, zoomLevel);
        }
}

/**
 * Sets the current user position as center of the map
 * and sets the 'coords' cookie which can later be used
 * for conducting tests
 */
function panToUserPosition() {
        //zoom to user position
        var coords;
        var geolocation_callback = function(position) {
                if (position) {
                        coords = new Object();
                        coords['lat'] = position.coords.latitude;
                        coords['long'] = position.coords.longitude;
                        coords['accuracy'] = position.coords.accuracy;
                        coords['altitude'] = position.coords.altitude;
                        coords['heading'] = position.coords.heading;
                        coords['speed'] = position.coords.speed;
                        coords['tstamp'] = position.timestamp;
                        //console.log("coords: "+coords);
                        var tmpcoords = JSON.stringify(coords);
                        //console.log("tmpcoords: "+tmpcoords);
                        setCookie('coords', tmpcoords, 3600);
                }
                var lat = coords.lat;
                var long = coords.long;

                var pt = new OpenLayers.LonLat(long, lat);
                pt.transform(
                        // degrees are degrees
                        new OpenLayers.Projection('EPSG:4326'),
                        // but your map is in meters (probably)
                        new OpenLayers.Projection('EPSG:900913'));
                var zoomLevel = 11;
                if (coords.accuracy !== null) {
                        if (coords.accuracy < 100) {
                                zoomLevel = 17;
                        }
                        else if (accuracy < 1000) {
                                coords.zoomLevel = 13;
                        }
                }
                map.setCenter(pt, zoomLevel);
        };
        var geolocation_error = function(error) {
                console.log("error retrieving user position")
        };

        //copied from geolocation, cannot directly use due to side effects
        var coords = getCookie('coords');
        //console.log(coords);
        if (coords) {
                coords = JSON.parse(coords);
                //console.log(tmpcoords);
        }
        if (coords && coords['lat'] > 0 && coords['long'] > 0) {
                geolocation_callback(false);
        }
        else {
                if (navigator.geolocation) {
                        var options = {
                                enableHighAccuracy: geo_HighAccuracy,
                                timeout: geo_timeout,
                                maximumAge: geo_maximumAge
                        };
                        navigator.geolocation.getCurrentPosition(geolocation_callback, geolocation_error, options);
                } else {
                        //not supported
                }
        }
}

/**
 * Get the layers from user input
 * and update the map accordingly
 * e.g. only heatmap, only points
 */
function setLayers() {

        var cardtyp = $("#map_options").val();
        var tmp = cardtyp.split('/');
        var typ = tmp[0];
        $("select[name=statistical_method]").removeAttr("disabled");
        //console.log($("input:radio:checked[name='check_layer']").val());
        if ($("input:radio:checked[name='check_layer']").val() == 'shapes') {
                points.setVisibility(false);
                heatmap.setVisibility(false);
                shapes.setVisibility(true);
                onFeatureUnselect();
                markers.setVisibility(false);
                click.deactivate();
        }
        else if ($("input:radio:checked[name='check_layer']").val() == 'heatmap') {
                points.setVisibility(false);
                heatmap.setVisibility(true);
                shapes.setVisibility(false);
                onFeatureUnselect();
                markers.setVisibility(false);
                click.deactivate();
        }
        else if ($("input:radio:checked[name='check_layer']").val() == 'points') {
                points.setVisibility(true);
                heatmap.setVisibility(false);
                shapes.setVisibility(false);
                shapes.setVisibility(false);
                markers.setVisibility(true);
                $("select[name=statistical_method]").attr("disabled","disabled");
                click.activate();
        }
        else if ($("input:radio:checked[name='check_layer']").val() == 'automatic' && map.getZoom() < points_heatmap_switch_level && typ == 'browser') {
                points.setVisibility(false);
                heatmap.setVisibility(false);
                shapes.setVisibility(true);
                onFeatureUnselect();
                markers.setVisibility(false);
                click.deactivate();
        }
        else if ($("input:radio:checked[name='check_layer']").val() == 'automatic' && map.getZoom() < points_heatmap_switch_level) {
                points.setVisibility(false);
                heatmap.setVisibility(true);
                shapes.setVisibility(false);
                onFeatureUnselect();
                markers.setVisibility(false);
                click.deactivate();
        }
        else if ($("input:radio:checked[name='check_layer']").val() == 'automatic' && map.getZoom() >= points_heatmap_switch_level && typ == 'browser') {
                points.setVisibility(true);
                heatmap.setVisibility(false);
                shapes.setVisibility(true);
                markers.setVisibility(true);
                click.activate();
        }
        else if ($("input:radio:checked[name='check_layer']").val() == 'automatic' && map.getZoom() >= points_heatmap_switch_level) {
                points.setVisibility(true);
                heatmap.setVisibility(true);
                markers.setVisibility(true);
                click.activate();
        }
}

function displayZoom() {
        //console.log(map.getZoom()+' - '+$("input:radio:checked[name='check_layer']").val());
        var cardtyp = $("#map_options").val();
        if (cardtyp === undefined) {
            return;
        }
        var tmp = cardtyp.split('/');
        var typ = tmp[0];
        if (map.getZoom() >= 17) {
                $('.zoomInItemInactive').css('display', 'none');
        }
        else {
                $('.zoomInItemInactive').css('display', 'block');
        }
        if (map.getZoom() <= 2) {
                $('.zoomOutItemInactive').css('display', 'none');
        }
        else {
                $('.zoomOutItemInactive').css('display', 'block');
        }
        if (typ != 'browser' && $("input:radio:checked[name='check_layer']").val() == 'automatic' && map.getZoom() < points_heatmap_switch_level) {
                points.setVisibility(false);
                heatmap.setVisibility(true);
                shapes.setVisibility(false);
                onFeatureUnselect();
                markers.setVisibility(false);
                click.deactivate();
        }
        else if (typ != 'browser' && $("input:radio:checked[name='check_layer']").val() == 'automatic' && map.getZoom() >= points_heatmap_switch_level) {
                points.setVisibility(true);
                heatmap.setVisibility(true);
                shapes.setVisibility(false);
                markers.setVisibility(true);
                click.activate();
        }
        else if (typ == 'browser' && $("input:radio:checked[name='check_layer']").val() == 'automatic' && map.getZoom() < points_heatmap_switch_level) {
                points.setVisibility(false);
                heatmap.setVisibility(false);
                shapes.setVisibility(true);
                onFeatureUnselect();
                markers.setVisibility(false);
                click.deactivate();
        }
        else if (typ == 'browser' && $("input:radio:checked[name='check_layer']").val() == 'automatic' && map.getZoom() >= points_heatmap_switch_level) {
                points.setVisibility(true);
                heatmap.setVisibility(false);
                shapes.setVisibility(true);
                markers.setVisibility(true);
                click.activate();
        }

}

function loadMarker(lonlat) {
        curFilterObj["highlight"] = getCookie("RMBTuuid");
        var json_data = {
                "language": selectedLanguage,
                coords: {
                        "x": lonlat.lon,
                        "y": lonlat.lat,
                        "z": map.zoom
                },
                filter: curFilterObj,
                options: curMapOptionObj
        };

        $.ajax({
                //url : "http://localhost:8080/RMBTMapServer/tiles/markers",
                url: mapProxy + "/" + mappath + "/tiles/markers",
                type: "post",
                dataType: "json",
                contentType: "application/json",
                data: JSON.stringify(json_data),
                success: function(data, textStatus, jqXHR) {
                        if (data.measurements && data.measurements[0]) {
                                addMarker(data.measurements[0].lat, data.measurements[0].lon, data.measurements);
                                selectStop.select(lastfeature);
                        }
                },
                error: function(xhr, ajaxOptions, thrownError) {
                        alert("Error beim settings-Abruf " + xhr.status + " " + thrownError + " " + ajaxOptions);
                }
        });
}

function onFeatureSelect(event) {

}

function onFeatureUnselect(event) {
        var feature = lastfeature;
        if (feature && feature.popup) {
                map.removePopup(feature.popup);
                feature.destroyPopup();
                delete feature.popup;
                markers.removeAllFeatures();
        }
}

function addMarker(lat, lon, data) {

        var lonlat = new OpenLayers.LonLat(lat, lon);

        feature = new OpenLayers.Feature(markers, lonlat);

        feature.closeBox = true;

        feature.popupClass = OpenLayers.Class(OpenLayers.Popup.FramedCloud, {
                size: new OpenLayers.Size(270, 50),
                minSize: new OpenLayers.Size(270, 50),
                maxSize: new OpenLayers.Size(270, 300),
                autoSize: true,
                panMapIfOutOfView: true
        });
        feature.data.popupContentHTML = (selectedLanguage == 'de') ? "<h1>MESSUNGEN</h1>" : "<h1>Measurements</h1>";
        feature.data.popupContentHTML += "<div class='infoWrap'>";
        feature.data.popupContentHTML += "<hr/>";
        $.each(data, function(i, item) {


                if (item.highlight == true) {
                        feature.data.popupContentHTML += "<h2 class='highlight'>";
                } else {
                        feature.data.popupContentHTML += "<h2>";
                }
                feature.data.popupContentHTML += item.time_string;
                feature.data.popupContentHTML += "<input type='button' style='float:right;' class='submit' onClick=\"window.open('/" + selectedLanguage + "/Opentest?" + item.open_test_uuid  + "')\" value='" + Lang.getString('moreInfo') + "' />";
                feature.data.popupContentHTML += "</h2>";
                feature.data.popupContentHTML += "<h3>" + Lang.getString("Measurement") + ":</h3>";
                $.each(item.measurement, function(j, elem) {
                        feature.data.popupContentHTML += "<div class='row'>";
                        feature.data.popupContentHTML += "<div class='rowlabel'>" + elem.title + "</div>";
                        feature.data.popupContentHTML += "<a href='https://www.rtr.at/" + selectedLanguage + "/rtr/netztestfaq_testergebnis#c25826' target='_blank'><div class='rowclassification classification" + elem.classification + "'>" + elem.classification + "</div></a>";
                        feature.data.popupContentHTML += "<div class='rowitem'>" + elem.value + "</div>";
                        feature.data.popupContentHTML += "</div>";
                });
                feature.data.popupContentHTML += "<h3>" + Lang.getString("Net") + ":</h3>";
                $.each(item.net, function(j, elem) {
                        feature.data.popupContentHTML += "<div class='row'>";
                        feature.data.popupContentHTML += "<div class='rowlabel'>" + elem.title + "</div>";
                        feature.data.popupContentHTML += "<div class='rowitem'>" + elem.value + "</div>";
                        feature.data.popupContentHTML += "</div>";
                });
                //feature.data.popupContentHTML += (selectedLanguage == 'de') ? "<div class='row'><a href=\"/de/Opentest?" + item.open_test_uuid + "\">Opendata-Eintrag</a></div>" : "<div class='row'><a href=\"/en/Opentest?" + item.open_test_uuid + "\">open data-entry</a></div>";
                feature.data.popupContentHTML += "<hr/>";
        });
        feature.data.popupContentHTML += "</div>";
        feature.data.overflow = "auto";

        var attributes
        var vectorStyle = {
                fillColor: "#3DFFFF",
                fillOpacity: 0.2,
                strokeColor: "#3DFFFF",
                strokeOpacity: 0.8,
                strokeDashstyleArray: "solid",
                strokeWidth: 1,
                pointRadius: 5
        }

        var marker = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.Point(lonlat.lon, lonlat.lat), attributes, vectorStyle);
        marker.feature = feature;

        markers.addFeatures([marker]);

        feature.popup = feature.createPopup(feature.closeBox);
        map.addPopup(feature.popup);

        lastfeature = feature;
}

function redrawLegend(cardtyp) {
        //redraw Legend
        //console.log(legends);
        //console.log(cardtyp);
        //console.log(legends[cardtyp].heatmap_color_high);
        $.each(legends[cardtyp], function(key, row) {
                $('#' + key).html(row);
        });

        var tr = "";
        var tr_length = legends[cardtyp].colors.length;
        var tr_length_minus_1 = tr_length - 1;
        $.each(legends[cardtyp].colors, function(key, value) {
                tr += '<td class="td_' + key + '"></td>';
        });
        tr += '<td class="td_' + tr_length + '"></td>';
        $('.legend_tr').html(tr);

        $("table.map_key_color td.td_0").css('background-color', legends[cardtyp].colors[0]);
        var c1, c2, key_minus_1;
        $.each(legends[cardtyp].colors, function(key, value) {
                if (key > 0 && key < tr_length) {
                        key_minus_1 = key - 1;
                        c1 = legends[cardtyp].colors[key_minus_1];
                        c2 = value;
                        background_value = 'background: -moz-linear-gradient(left, ' + c1 + ' 0%, ' + c2 + ' 100%); background: -webkit-gradient(linear, left top, right top, color-stop(0%,' + c1 + '), color-stop(100%,' + c2 + ')); background: -webkit-linear-gradient(left, ' + c1 + ' 0%,' + c2 + ' 100%); background: -o-linear-gradient(left, ' + c1 + ' 0%,' + c2 + ' 100%); background: -ms-linear-gradient(left, ' + c1 + ' 0%,' + c2 + ' 100%); background: linear-gradient(to right, ' + c1 + ' 0%,' + c2 + ' 100%); filter: progid:DXImageTransform.Microsoft.gradient( startColorstr="' + c1 + '", endColorstr="' + c2 + '",GradientType=1 ); ';
                        $("table.map_key_color td.td_" + key).attr('style', background_value);
                }

        });
        $("table.map_key_color td.td_" + legends[cardtyp].colors.length).css('background-color', legends[cardtyp].colors[tr_length_minus_1]);

        var cap = "";
        var cap_length = legends[cardtyp].heatmap_captions.length;
        var cap_length_minus_1 = cap_length - 1;
        var cap_max = cap_length * 2 + 1;
        var cap_val;

        for (var i = 0; i < cap_max; i++) {
                cap_val = (i - 1) / 2;
                if (i % 2 == 1)
                        cap += '<td class="td_' + i + ' value">' + legends[cardtyp].heatmap_captions[cap_val] + '</td>';
                else
                        cap += '<td class="td_' + i + ' spacer"></td>';
        }
        cap += '<td class="unit">' + legends[cardtyp].heatmap_caption_unit + '</td>';
        $('#heatmap_captions').html(cap);

        if (legends[cardtyp].classification_high > legends[cardtyp].classification_low) {
                $("#classification_high").html(' &ge; ' + legends[cardtyp].classification_high + ' ' + legends[cardtyp].heatmap_caption_unit + ' &gt; ');
                $("#classification_low").html(' &ge; ' + legends[cardtyp].classification_low + ' ' + legends[cardtyp].heatmap_caption_unit + ' &gt; ');
        }
        else if (legends[cardtyp].classification_high < legends[cardtyp].classification_low) {
                $("#classification_high").html(' &le; ' + legends[cardtyp].classification_high + ' ' + legends[cardtyp].heatmap_caption_unit + ' &lt; ');
                $("#classification_low").html(' &le; ' + legends[cardtyp].classification_low + ' ' + legends[cardtyp].heatmap_caption_unit + ' &lt; ');
        }

}

function redrawOverlay() {
        var as = $('#auswahl_selector select');
        var auswahl = '';
        var tmp, typ, cardtyp, background_value;
        curMapOptionObj = {};
        $.each(as, function(key, row) {
                if ($(row).val().length > 0) {
                        var tmp = $(row).attr("name");
                        auswahl += '&' + $(row).attr("name") + '=' + $(row).val();
                        curMapOptionObj[$(row).attr("name")] = $(row).val();
                        cardtyp = $(row).val()
                        tmp = cardtyp.split('/');
                        typ = tmp[0];
                        $('#filter_selector>div').css("display", "none");
                        $('#filter_' + typ).css("display", "block");
                        //console.log(cardtyp);


                        if ($("input:radio:checked[name='check_layer']").val() == 'heatmap' && typ == 'browser') {

                                points.setVisibility(false);
                                heatmap.setVisibility(false);
                                markers.setVisibility(false);
                                shapes.setVisibility(true);

                        }
                        else if ($("input:radio:checked[name='check_layer']").val() == 'heatmap' && typ != 'browser') {
                                points.setVisibility(false);
                                heatmap.setVisibility(true);
                                shapes.setVisibility(false);
                                onFeatureUnselect();
                                markers.setVisibility(false);
                                click.deactivate();

                        }
                        else if ($("input:radio:checked[name='check_layer']").val() == 'points') {
                                points.setVisibility(true);
                                heatmap.setVisibility(false);
                                shapes.setVisibility(false);
                                markers.setVisibility(true);
                                click.activate();

                        }
                        else if ($("input:radio:checked[name='check_layer']").val() == 'automatic' && map.getZoom() < points_heatmap_switch_level && typ == 'browser') {
                                points.setVisibility(false);
                                heatmap.setVisibility(false);
                                shapes.setVisibility(true);
                                onFeatureUnselect();
                                markers.setVisibility(false);
                                click.deactivate();

                        }
                        else if ($("input:radio:checked[name='check_layer']").val() == 'automatic' && map.getZoom() < points_heatmap_switch_level && typ != 'browser') {
                                points.setVisibility(false);
                                heatmap.setVisibility(true);
                                shapes.setVisibility(false);
                                onFeatureUnselect();
                                markers.setVisibility(false);
                                click.deactivate();

                        }
                        else if ($("input:radio:checked[name='check_layer']").val() == 'automatic' && map.getZoom() >= points_heatmap_switch_level && typ == 'browser') {
                                points.setVisibility(true);
                                heatmap.setVisibility(false);
                                markers.setVisibility(true);
                                shapes.setVisibility(true);
                                click.activate();

                        }
                        else if ($("input:radio:checked[name='check_layer']").val() == 'automatic' && map.getZoom() >= points_heatmap_switch_level && typ != 'browser') {
                                points.setVisibility(true);
                                heatmap.setVisibility(true);
                                markers.setVisibility(true);
                                shapes.setVisibility(false);
                                click.activate();

                        }
                        //}
                }

        });


        var es = $('#filter_' + typ + ' select');
        var filter = '?highlight=';
        filter += (getCookie("RMBTuuid")) ? getCookie("RMBTuuid") : "null";
        curFilterObj = {};
        $.each(es, function(key, row) {
                if ($(row).val().length > 0) {
                        var tmp = $(row).attr("name");
                        filter += '&' + $(row).attr("name") + '=' + $(row).val();
                        curFilterObj[$(row).attr("name")] = $(row).val();
                }

        });
        
        //if qostest -> add source parameter
        if (developerCode > 0) {
            filter += "&developer_code=" + developerCode;
            curFilterObj['developer_code'] = developerCode;
        }

        var points_url = URL_MAP_SERVER + '/points/${z}/${x}/${y}.png' + filter + auswahl;
        points.url = points_url;
        points.redraw(true);

        var heatmap_url = URL_MAP_SERVER + '/heatmap/${z}/${x}/${y}.png' + filter + auswahl;
        heatmap.url = heatmap_url;
        heatmap.redraw(true);

        var shapes_url = URL_MAP_SERVER + '/shapes/${z}/${x}/${y}.png' + filter + auswahl;
        shapes.url = shapes_url;
        shapes.redraw(true);

        // Remove open Popups
        onFeatureUnselect(null);

        redrawLegend(cardtyp);


}

function defaultMapFilter() {
        var as = $('#auswahl_selector select');
        var auswahl = '';
        var tmp, typ, cardtyp, background_value;
        curMapOptionObj = {};
        $.each(as, function(key, row) {

                if ($(row).val().length > 0) {
                        var tmp = $(row).attr("name");
                        auswahl += '&' + $(row).attr("name") + '=' + $(row).val();
                        curMapOptionObj[$(row).attr("name")] = $(row).val();
                        cardtyp = $(row).val()
                        tmp = cardtyp.split('/');
                        typ = tmp[0];
                        $('#filter_selector>div').css("display", "none");
                        $('#filter_' + typ).css("display", "block");

                }

        });

        var es = $('#filter_' + typ + ' select');
        //quick hack to disable test-highlighting and thus make caching effective
        var filter = '?null'; //'?highlight=' + getCookie("RMBTuuid");
        curFilterObj = {};
        $.each(es, function(key, row) {
                if ($(row).val().length > 0) {
                        var tmp = $(row).attr("name");
                        filter += '&' + $(row).attr("name") + '=' + $(row).val();
                        curFilterObj[$(row).attr("name")] = $(row).val();
                }

        });
                       
        //if qostest -> add source parameter
        if (developerCode > 0) {
            filter += "&developer_code=" + developerCode;
            curFilterObj['developer_code'] = developerCode;
        }
        
        points_url = URL_MAP_SERVER + '/points/${z}/${x}/${y}.png' + filter + auswahl;

        heatmap_url = URL_MAP_SERVER + '/heatmap/${z}/${x}/${y}.png' + filter + auswahl;

        shapes_url = URL_MAP_SERVER + '/shapes/${z}/${x}/${y}.png' + filter + auswahl;

        heatmap = new OpenLayers.Layer.XYZ("Heatmap",
                //         	        "http://localhost:8080/RMBTMapServer/tiles/heatmap/${z}/${x}/${y}.png",
                heatmap_url,
                {
                        isBaseLayer: false,
                        sphericalMercator: true,
                        transparent: "true",
                        format: "image/png",
                        displayInLayerSwitcher: false
                });

        shapes = new OpenLayers.Layer.XYZ("Shapes",
                //         	        "http://localhost:8080/RMBTMapServer/tiles/heatmap/${z}/${x}/${y}.png",
                shapes_url,
                {
                        isBaseLayer: false,
                        sphericalMercator: true,
                        transparent: "true",
                        format: "image/png",
                        displayInLayerSwitcher: false
                });

        points = new OpenLayers.Layer.XYZ("Points",
                //             	        "http://localhost:8080/RMBTMapServer/tiles/points/${z}/${x}/${y}.png",
                points_url,
                {
                        isBaseLayer: false,
                        sphericalMercator: true,
                        transparent: "true",
                        format: "image/png",
                        displayInLayerSwitcher: false
                });
                
        map.addLayers([heatmap, points, markers, shapes]);

        points.setVisibility(false);
        markers.setVisibility(false);
        shapes.setVisibility(false);

        //also update the layers in case
        //that the user's browser did some
        //local form caching
        setLayers();
}

// "Lightbox":
$("#lightboxbutton").live("click", function() {
        if (mapState === "small")
                switchToLargeMap();
        else
                switchToSmallMap();
        
});

//currently display map state - can be "small" or "large"
var mapState = "small";
var mapStateSmallOrig;


//Resize event
$(window).resize(function() {
    if (mapState === "large") {
        var mapId = "#speedtestmap";
        var mapStateButtonId = "#lightboxbutton";
        
        var windowHeight = $(window).height();
        var windowWidth = $(window).width();
        
        $(mapId).css("left","0px");
        var leftOffset = $(mapId).offset().left;
        
        $(mapId).css("width", windowWidth + "px");
        $(mapId).css("height", windowHeight + "px");
        $(mapId).css("left", -leftOffset + "px");
        
        $(mapStateButtonId).css("left", (windowWidth - leftOffset) - 150 + "px")
        
    }
});


/**
 * switch to the small map state (=standard state)
 */
function switchToSmallMap() {
        var mapId = "#speedtestmap";
        var mapStateButtonId = "#lightboxbutton";
                
        $(mapStateButtonId).hide();
        
        //animate back
        $(mapId).animate({
                left: (mapStateSmallOrig.leftOffsetBefore - mapStateSmallOrig.leftOffset) + "px",
                width: mapStateSmallOrig.width,
                height: mapStateSmallOrig.height
                        //height: windowHeight
        }, {
                duration: 400,
                progress: function() {
                       map.updateSize();
                },
                complete: function() {
                        map.updateSize();
                        $(mapStateButtonId).removeAttr("style");
                        $(mapStateButtonId).show();
                        $(mapStateButtonId).val(Lang.getString("largeView"));
                        
                        //now, reset everything
                        $(mapId).removeAttr("style");
                }});
        
        
        mapState = "small";
        
}

/**
 * switch to the large map state
 */
function switchToLargeMap() {
        var mapId = "#speedtestmap";
        var mapStateButtonId = "#lightboxbutton";
        
        
        
        //get screen size
        var windowHeight = $(window).height();
        var windowWidth = $(window).width();
        
        $(mapId).css("position","absolute");
        
        var leftOffsetBefore = $(mapId).offset().left;
        
        $(mapStateButtonId).hide();
        $(mapId).css("left","0px");
        
        var leftOffset = $(mapId).offset().left;
        $(mapId).css("left",(leftOffsetBefore-leftOffset) + "px");
        
        var filterTopOffset = $("#auswahl_selector").offset().top;
        
        //save original positions
        mapStateSmallOrig = {
                leftOffsetBefore: leftOffsetBefore,
                leftOffset: leftOffset,
                height: $(mapId).height(),
                width: $(mapId).width(),
                mapStateButtonLeft: $(mapStateButtonId).position().left

        };
        

        $(mapId).animate({
                left: -leftOffset + "px",
                width: windowWidth,
                height: windowHeight
        }, {
                duration: 400,
                progress: function(animation, progress, remainingMs) {
                        map.updateSize();
                },
                complete: function() {
                        //reset width since we now have a scrollbar
                        var newWidth = $(window).width();
                        $(mapId).css("width",newWidth);
                        
                        var newLeftOffset = $(mapId).offset().left;
                        if (newLeftOffset<0) {
                                $(mapId).css("left",(-leftOffset - newLeftOffset));
                        }

                        map.updateSize();
                        $(mapStateButtonId).css("left", (windowWidth - leftOffset) - 150 + "px")
                        $(mapStateButtonId).show();
                        $(mapStateButtonId).val(Lang.getString("smallView"));
                }
        });
        
        //scroll to the map
        $('html, body').animate({ scrollTop: filterTopOffset }, 'slow');
        
        mapState = "large";
}
